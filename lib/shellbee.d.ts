// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../atma-utils
//   ../child_process

declare module 'shellbee' {
    import { Net } from 'shellbee/ps/Net';
    import { PsList } from 'shellbee/ps/PsList';
    import { Shell } from 'shellbee/Shell';
    export { restartSelf } from 'shellbee/util/restartSelf';
    export { Shell };
    export const run: typeof Shell.run;
    export const ShellUtils: {
        process: {
            getAll: typeof PsList.getAll;
            getByPort: typeof Net.findByPort;
            kill: typeof PsList.kill;
        };
    };
}

declare module 'shellbee/ps/Net' {
    export namespace Net {
        interface IProcess {
            pid: string;
            status?: string;
            protocol: 'tcp' | 'udp' | string;
        }
        export function findByPort(port: string | number): Promise<IProcess[]>;
        export {};
    }
}

declare module 'shellbee/ps/PsList' {
    interface IProcess {
        /** ParentProcessId */
        pid: number;
        /** ProcessId */
        ppid: number;
        /** UserId (nix) */
        uid?: number;
        /** GroupId (nix) */
        gid?: number;
        /** ExecutablePath */
        bin: string;
        /** Name */
        name: string;
        /** Command  */
        cmd: string;
    }
    export namespace PsList {
        function getAll(): Promise<IProcess[]>;
        function kill(pid: number | string): Promise<any>;
    }
    export {};
}

declare module 'shellbee/Shell' {
    import { class_EventEmitter } from 'atma-utils';
    import * as child_process from 'child_process';
    import { IShellParams } from 'shellbee/interface/IProcessParams';
    import { ICommandOptions } from 'shellbee/interface/ICommandOptions';
    import { CommunicationChannel } from 'shellbee/CommunicationChannel';
    export type ProcessEventType = 'process_start' | 'process_exception' | 'process_exit' | 'process_ready' | 'process_stdout' | 'process_stderr';
    export interface IProcessEvents {
            process_start(data: {
                    command: string;
            }): any;
            process_exception(data: {
                    command: string;
                    error: Error | string;
            }): any;
            process_exit(data: {
                    command: string;
                    code: number;
                    result: ProcessResult;
            }): any;
            process_ready(data: {
                    command: string;
            }): any;
            process_stdout(data: {
                    command: string;
                    buffer: Buffer | string;
            }): any;
            process_stderr(data: {
                    command: string;
                    buffer: Buffer | string;
            }): any;
            channel_closed(data: {
                    channel: CommunicationChannel;
            }): any;
            channel_created(data: {
                    channel: CommunicationChannel;
            }): any;
    }
    export class Shell extends class_EventEmitter<IProcessEvents> {
            static ipc: typeof CommunicationChannel.ipc;
            children: {
                    process: child_process.ChildProcess;
                    options: ICommandOptions;
            }[];
            errors: {
                    command: string;
                    error: Error;
            }[];
            lastCode: number;
            currentOptions: ICommandOptions;
            commands: ICommandOptions[];
            commandsQueue: ICommandOptions[];
            results: ProcessResult[];
            extracted: {};
            state: ShellState;
            promise: Promise<Shell>;
            std: string[];
            stderr: string[];
            stdout: string[];
            start: Date;
            end: Date;
            isBusy: boolean;
            isReady: boolean;
            channel: CommunicationChannel;
            params: IShellParams;
            constructor(params: IShellParams);
            /**
                * Static "run" intializes the Shell instance and calls "run" instance method.
                * @return Returns a promise, which is resolved after all commands exit.
                */
            static run(command: string): Promise<Shell>;
            static run(commands: string[]): Promise<Shell>;
            static run(params: IShellParams): Promise<Shell>;
            /**
                * "Run" starts the command
                * @returns Promise, which is resolved after the executables are completed.
                */
            run(): Promise<Shell>;
            static factory(config: IShellParams): Pick<typeof Shell, 'run'>;
            onStart(cb: (data: {
                    command: string;
            }) => void): this;
            onStdout(cb: (data: {
                    command: string;
                    buffer: string;
            }) => void): this;
            onStderr(cb: (data: {
                    command: string;
                    buffer: string;
            }) => void): this;
            onExit(cb: (data: {
                    command: string;
                    code: number;
                    result: ProcessResult;
            }) => void): this;
            /** When rgxReady is specified the event will be called */
            onReady(cb: (result: {
                    command: string;
            }) => void): this;
            onReadyAsync(): Promise<{
                    command: string;
            }>;
            onComplete(cb: (shell: Shell) => void): this;
            onCompleteAsync(): Promise<this>;
            kill(signal?: number | NodeJS.Signals): any;
            kill(options?: TKillOptions): any;
            /** Uses tree-kill to terminate the tree */
            terminate(): Promise<unknown>;
            send<TOut = any>(method: string, ...args: any[]): Promise<TOut>;
            restart(index?: number): any;
            restart(command?: string): any;
    }
    export class ProcessResult {
            options: ICommandOptions;
            pid: number;
            std: string[];
            stdout: string[];
            stderr: string[];
            resultCode: number;
            error: Error;
            constructor(options: ICommandOptions);
    }
    enum ShellState {
            Empty = -1,
            Initial = 0,
            Started = 1
    }
    type TKillOptions = {
            signal?: number | NodeJS.Signals;
            commandIdx?: number;
            terminateAfter?: number;
    };
    export {};
}

declare module 'shellbee/util/restartSelf' {
    export function restartSelf(): void;
}

declare module 'shellbee/interface/IProcessParams' {
    export interface IShellParams {
        command?: string | IProcessSingleParams;
        commands?: (string | IProcessSingleParams)[];
        detached?: boolean;
        cwd?: string;
        matchReady?: RegExp;
        silent?: boolean;
        parallel?: boolean;
        fork?: boolean;
        ipc?: boolean;
        restartOnErrorExit?: boolean | {
            delayMs?: number;
            maxRestartTimespanMs?: number;
            maxRestartCount?: number;
        };
        restartOnStalledOutput?: {
            emptyOutputInterval: number;
        };
        restartOptions?: {
            beforeRestartHandler?: string;
        };
        verbose?: boolean;
        timeoutMs?: number;
        /**
         * Command shell wrapper, e.g. ""c:\\Program Files\\Git\\bin\\bash.exe" -c "%COMMAND%"
         * or shell prefix like ["cmd.exe", "/C"]
         */
        shell?: string | string[];
    }
    export interface IProcessSingleParams {
        command: string;
        cwd?: string;
        detached?: boolean;
        matchReady?: RegExp;
        fork?: boolean;
        ipc?: boolean;
        restartOnError?: boolean;
        extract: {
            [key: string]: (output: string) => any;
        };
    }
}

declare module 'shellbee/interface/ICommandOptions' {
    import { IValueExtractors } from 'shellbee/interface/IValueExtractors';
    export interface ICommandOptions {
        exec: string;
        args: string[];
        cwd: string;
        detached: boolean;
        command: string;
        matchReady: RegExp;
        extract: IValueExtractors;
        fork: boolean;
        ipc: boolean;
        restartOnError: boolean;
        /**
          * Command will be interpolated using extracted values from prev command
          * $ cd {{path}}
          **/
        interpolate?: boolean;
    }
}

declare module 'shellbee/CommunicationChannel' {
    import { ChildProcess } from 'child_process';
    export class CommunicationChannel {
        child: ChildProcess;
        static ipc(handlers: {
            [method: string]: (...args: any[]) => void | Promise<any>;
        }): void;
        awaiters: {
            [id: string]: {
                promise: any;
                timestamp: any;
            };
        };
        constructor(child: ChildProcess, timeoutMs: number);
        call<T = any>(method: string, ...args: any[]): Promise<T>;
        checkTimeout(): void;
        onError(error: any): void;
        onStdError(str: string): void;
    }
}

declare module 'shellbee/interface/IValueExtractors' {
    export interface IValueExtractor<T = any> {
        (str: string): T;
    }
    export interface IValueExtractors {
        [key: string]: IValueExtractor;
    }
}

